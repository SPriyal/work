<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0037)http://www.youdao.com/nanti/news.html -->
<HTML xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>2010网易编程挑战赛</TITLE>
<META http-equiv=Content-Type content="text/html; charset=UTF-8">
<META http-equiv=X-UA-Compatible content=IE=EmulateIE7>
<META content="" name=description><LINK href="http://www.163.com/favicon.ico" 
type=image/x-icon rel="shortcut icon">
<STYLE>BODY {
	MARGIN-TOP: 0px; FONT-SIZE: 14px; BACKGROUND: url(images/top_pic_back.jpg) repeat-x; COLOR: #2b2b2b; FONT-FAMILY: Verdana, Arial
}
P {
	MARGIN: 8px 0px
}
A {
	COLOR: #686868; TEXT-DECORATION: none
}
A:hover {
	COLOR: #1e50a2; TEXT-DECORATION: underline
}
IMG {
	BORDER-TOP-WIDTH: 0px; BORDER-LEFT-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; BORDER-RIGHT-WIDTH: 0px
}
UL {
	PADDING-RIGHT: 0pt; LIST-STYLE: none none outside; PADDING-LEFT: 0pt; PADDING-BOTTOM: 0pt; MARGIN: 0pt; PADDING-TOP: 0pt
}
LI {
	PADDING-RIGHT: 0pt; LIST-STYLE: none none outside; PADDING-LEFT: 0pt; PADDING-BOTTOM: 0pt; MARGIN: 0pt; PADDING-TOP: 0pt
}
.picborder {
	BORDER-RIGHT: #dcdcdc 1px solid; BORDER-TOP: #dcdcdc 1px solid; BORDER-LEFT: #dcdcdc 1px solid; BORDER-BOTTOM: #dcdcdc 1px solid
}
.gray {
	COLOR: #808080
}
.red {
	COLOR: #ed1010
}
.double_star {
	FONT-SIZE: 9px
}
#copyright_navigation {
	BORDER-TOP: #dcdcdc 1px solid; FONT-SIZE: 12px; OVERFLOW: hidden; WIDTH: 100%; COLOR: #808080; TEXT-ALIGN: center
}
#warp {
	MARGIN: 0px auto; WIDTH: 980px
}
#topbanner {
	OVERFLOW: hidden; WIDTH: 980px; HEIGHT: 249px
}
#title_navigation {
	WIDTH: 980px; HEIGHT: 38px
}
.ver20all {
	OVERFLOW: hidden; WIDTH: 100%; HEIGHT: 20px
}
.ver15 {
	OVERFLOW: hidden; WIDTH: 705px; HEIGHT: 15px
}
.ver20 {
	OVERFLOW: hidden; WIDTH: 705px; HEIGHT: 20px
}
.ver30 {
	OVERFLOW: hidden; WIDTH: 705px; HEIGHT: 30px
}
.ver15right {
	OVERFLOW: hidden; WIDTH: 240px; HEIGHT: 15px
}
.space_area {
	WIDTH: 22px; HEIGHT: 20px
}
#vessel {
	WIDTH: 980px
}
#vessel .left {
	DISPLAY: block; FLOAT: left; WIDTH: 705px
}
#vessel .right {
	DISPLAY: block; FLOAT: right; WIDTH: 240px
}
.schedule_area {
	BACKGROUND: url(images/left_title_richeng.jpg) repeat-x; OVERFLOW: hidden; WIDTH: 705px; COLOR: #686868; HEIGHT: 26px
}
.shape_area {
	BACKGROUND: url(images/richeng_area.jpg) repeat-x; OVERFLOW: hidden; WIDTH: 705px; COLOR: #686868; HEIGHT: 107px
}
.shape_area .onearea {
	PADDING-RIGHT: 0px; DISPLAY: block; PADDING-LEFT: 42px; FLOAT: left; PADDING-BOTTOM: 0px; COLOR: #686868; PADDING-TOP: 37px
}
.shape_area .twoarea {
	PADDING-RIGHT: 0px; DISPLAY: block; PADDING-LEFT: 52px; FLOAT: left; PADDING-BOTTOM: 0px; COLOR: #686868; PADDING-TOP: 20px
}
.shape_area .threearea {
	PADDING-RIGHT: 0px; DISPLAY: block; PADDING-LEFT: 55px; FLOAT: left; PADDING-BOTTOM: 0px; COLOR: #686868; PADDING-TOP: 20px
}
.shape_area .fourarea {
	PADDING-RIGHT: 0px; DISPLAY: block; PADDING-LEFT: 62px; FLOAT: left; PADDING-BOTTOM: 0px; COLOR: #686868; PADDING-TOP: 37px
}
.f12 {
	FONT-SIZE: 12px
}
.news_area {
	BACKGROUND: url(images/left_title_xinwen.jpg) repeat-x; OVERFLOW: hidden; WIDTH: 705px; COLOR: #686868; HEIGHT: 26px
}
.rect_top {
	BACKGROUND: url(images/squre_white_top.gif) no-repeat; OVERFLOW: hidden; WIDTH: 705px; COLOR: #686868; HEIGHT: 19px
}
.rect_middle {
	BACKGROUND: url(images/squre_white_middle.gif) repeat-y; OVERFLOW: hidden; WIDTH: 705px; COLOR: #686868
}
.rect_middle .content {
	PADDING-RIGHT: 0px; PADDING-LEFT: 25px; PADDING-BOTTOM: 0px; LINE-HEIGHT: 180%; PADDING-TOP: 0px
}
.rect_bottom {
	BACKGROUND: url(images/squre_white_bottom.gif) no-repeat; OVERFLOW: hidden; WIDTH: 705px; COLOR: #686868; HEIGHT: 19px
}
.notice_area_top {
	BACKGROUND: url(images/right_tongzhi_title.gif) repeat-x; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868; HEIGHT: 44px
}
.notice_area_middle {
	BACKGROUND: url(images/right_lan_background.gif) repeat-y; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868
}
.notice_area_middle .content {
	PADDING-RIGHT: 0px; PADDING-LEFT: 10px; FONT-SIZE: 12px; PADDING-BOTTOM: 10px; LINE-HEIGHT: 180%; PADDING-TOP: 5px
}
.notice_area_bottom {
	BACKGROUND: url(images/right_lan_bottom.gif) repeat-x; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868; HEIGHT: 9px
}
.poj_area_top {
	BACKGROUND: url(images/right_poj_title.gif) repeat-x; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868; HEIGHT: 44px
}
.poj_area_middle {
	BACKGROUND: url(images/right_lan_background.gif) repeat-y; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868
}
.poj_area_middle .content {
	PADDING-RIGHT: 0px; PADDING-LEFT: 20px; FONT-SIZE: 12px; PADDING-BOTTOM: 10px; WIDTH: 210px; LINE-HEIGHT: 180%; PADDING-TOP: 5px
}
.poj_area_middle .content A {
	COLOR: #1e50a2
}
.clew_area_top {
	BACKGROUND: url(images/right_tishi_title.gif) repeat-x; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868; HEIGHT: 44px
}
.clew_area_middle {
	BACKGROUND: url(images/right_lan_background.gif) repeat-y; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868
}
.clew_area_middle .content {
	PADDING-RIGHT: 0px; PADDING-LEFT: 20px; FONT-SIZE: 12px; PADDING-BOTTOM: 10px; WIDTH: 210px; LINE-HEIGHT: 180%; PADDING-TOP: 5px
}
.clew_area_middle .content A {
	COLOR: #1e50a2
}
.discuss_area_top {
	BACKGROUND: url(images/right_hudong_title.gif) repeat-x; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868; HEIGHT: 44px
}
.discuss_area_middle {
	BACKGROUND: url(images/right_lan_background.gif) repeat-y; OVERFLOW: hidden; WIDTH: 240px; COLOR: #686868
}
.discuss_area_middle .content {
	PADDING-RIGHT: 0px; PADDING-LEFT: 20px; FONT-SIZE: 12px; PADDING-BOTTOM: 10px; WIDTH: 210px; LINE-HEIGHT: 180%; PADDING-TOP: 5px
}
.discuss_area_middle .content A {
	COLOR: #1e50a2
}
.ver36 {
	OVERFLOW: hidden; WIDTH: 705px; HEIGHT: 36px
}
.ver12 {
	OVERFLOW: hidden; WIDTH: 705px; HEIGHT: 12px
}
.news_title {
	PADDING-RIGHT: 0px; PADDING-LEFT: 30px; FONT-WEIGHT: bold; FONT-SIZE: 16px; PADDING-BOTTOM: 0px; WIDTH: 705px; PADDING-TOP: 0px
}
.news_title_line {
	BACKGROUND: url(images/doubleline.gif) repeat-x; HEIGHT: 3px
}
.news_title_biaoti {
	PADDING-RIGHT: 0px; PADDING-LEFT: 0px; FONT-WEIGHT: bold; PADDING-BOTTOM: 2px; PADDING-TOP: 15px
}
.news_title_content {
	PADDING-RIGHT: 30px; PADDING-LEFT: 30px; PADDING-BOTTOM: 0px; WIDTH: 650px; LINE-HEIGHT: 180%; PADDING-TOP: 0px
}
.news_title_notice {
	FONT-SIZE: 12px; COLOR: #808080
}
.news_title_notice A {
	COLOR: #1e50a2
}
.newscontenttitle {
	PADDING-RIGHT: 0px; PADDING-LEFT: 0px; FONT-WEIGHT: bold; FONT-SIZE: 16px; PADDING-BOTTOM: 10px; COLOR: #fff; PADDING-TOP: 10px; BACKGROUND-COLOR: #3f8014
}
.newscontenttitle2 {
	PADDING-RIGHT: 0px; PADDING-LEFT: 0px; FONT-WEIGHT: bold; FONT-SIZE: 14px; PADDING-BOTTOM: 0px; PADDING-TOP: 20px
}
.newscontenttitle3 {
	PADDING-RIGHT: 0px; PADDING-LEFT: 0px; FONT-WEIGHT: bold; FONT-SIZE: 14px; PADDING-BOTTOM: 0px; COLOR: #a31b09; PADDING-TOP: 20px
}
</STYLE>

<SCRIPT type=text/JavaScript>
<!--
function MM_findObj(n, d) { //v4.01
  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {
    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}
  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];
  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document);
  if(!x && d.getElementById) x=d.getElementById(n); return x;
}

function MM_preloadImages() { //v3.0
  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();
    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)
    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}
}

function MM_swapImgRestore() { //v3.0
  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;
}

function MM_swapImage() { //v3.0
  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)
   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}
}
//-->
</SCRIPT>

<META content="MSHTML 6.00.2900.5945" name=GENERATOR></HEAD>
<BODY 
onload="MM_preloadImages('images/gaishu_button_blue_hover.jpg','images/guize_button_blue_hover.jpg','images/zhinan_button_blue_hover.jpg','images/baoming_button_blue_hover.jpg','images/qa_button_blue_hover.jpg','images/guanyu_button_blue_hover.jpg','images/shouye_button_blue_hover.jpg')">
<DIV id=warp><!-- 容器开始 --><!-- 头部开始 -->
<DIV id=topbanner><IMG height=249 alt="" src="2010网易编程挑战赛.files/title_image.jpg" 
width=980 useMap=#Map border=0> <MAP id=Map name=Map><AREA shape=RECT 
  target=blank coords=608,3,747,56 href="http://www.163.com/"><AREA shape=RECT 
  target=blank/ coords=762,4,928,58 href="http://www.youdao.com/"><AREA 
  shape=RECT coords=38,153,202,203 
  href="http://www.youdao.com/nanti/apply.php"><AREA shape=RECT target=blank 
  coords=212,150,378,206 href="http://www.youdao.com/nanti/mi2010/"></MAP></DIV>
<DIV id=title_navigation><A 
onmouseover="MM_swapImage('Image16','','images/shouye_button_blue_hover.jpg',1)" 
onmouseout=MM_swapImgRestore() 
href="http://www.youdao.com/nanti/index.html"><IMG id=Image16 height=38 
src="2010网易编程挑战赛.files/shouye_button_blue.jpg" width=118 border=0 
name=Image16></A><A 
onmouseover="MM_swapImage('Image23','','images/gaishu_button_blue_hover.jpg',1)" 
onmouseout=MM_swapImgRestore() 
href="http://www.youdao.com/nanti/overview.html"><IMG id=Image23 height=38 
src="2010网易编程挑战赛.files/gaishu_button_blue.jpg" width=124 border=0 
name=Image23></A><A 
onmouseover="MM_swapImage('Image24','','images/guize_button_blue_hover.jpg',1)" 
onmouseout=MM_swapImgRestore() 
href="http://www.youdao.com/nanti/rules.html"><IMG id=Image24 height=38 
src="2010网易编程挑战赛.files/guize_button_blue.jpg" width=124 border=0 
name=Image24></A><A 
onmouseover="MM_swapImage('Image25','','images/zhinan_button_blue_hover.jpg',1)" 
onmouseout=MM_swapImgRestore() 
href="http://www.youdao.com/nanti/guide.html"><IMG id=Image25 height=38 
src="2010网易编程挑战赛.files/zhinan_button_blue.jpg" width=124 border=0 
name=Image25></A><A 
onmouseover="MM_swapImage('Image26','','images/baoming_button_blue_hover.jpg',1)" 
onmouseout=MM_swapImgRestore() href="http://www.youdao.com/nanti/apply.php"><IMG 
id=Image26 height=38 src="2010网易编程挑战赛.files/baoming_button_blue.jpg" width=118 
border=0 name=Image26></A><A 
onmouseover="MM_swapImage('Image27','','images/qa_button_blue_hover.jpg',1)" 
onmouseout=MM_swapImgRestore() href="http://www.youdao.com/nanti/qa.html"><IMG 
id=Image27 height=38 src="2010网易编程挑战赛.files/qa_button_blue.jpg" width=124 
border=0 name=Image27></A><A 
onmouseover="MM_swapImage('Image29','','images/chengji_button_blue_hover.jpg',1)" 
onmouseout=MM_swapImgRestore() 
href="http://www.youdao.com/nanti/nanti_results.html"><IMG id=Image29 height=38 
src="2010网易编程挑战赛.files/chengji_button_blue.jpg" width=124 border=0 
name=Image29></A><A 
onmouseover="MM_swapImage('Image28','','images/guanyu_button_blue_hover.jpg',1)" 
onmouseout=MM_swapImgRestore() 
href="http://www.youdao.com/nanti/aboutyoudao.html"><IMG id=Image28 height=38 
src="2010网易编程挑战赛.files/guanyu_button_blue.jpg" width=124 border=0 
name=Image28></A></DIV>
<DIV class=ver15></DIV><!-- 头部结束 --><!-- 内容开始 -->
<DIV id=vessel><!-- 左栏开始 -->
<DIV class=left>
<DIV class=ver36></DIV><!-- 概述内容开始 -->
<DIV class=news_title>"有道难题2009"复赛题目与解题报告</DIV>
<DIV class=ver12></DIV>
<DIV class=news_title_line></DIV>
<DIV class=ver20></DIV>
<DIV class=news_title_content>
<DIV class=newscontenttitle>&nbsp;&nbsp;题目: UnrepeatingNunbers (350 
points)</DIV>
<DIV class=newscontenttitle2>Problem 
Statement:</DIV>如果一个数字十进制表达时，不存在连续两位数字相等，则称之为“不重复数”。例如，105，1234和12121都是“不重复数”，而11，100和1225不算。给定一个long类型数字A，返回大于A的最小“不重复数”。 

<DIV class=newscontenttitle2>Definition:</DIV>Class: UnrepeatingNumbers 
<BR>Method: next <BR>Parameters: long <BR>Returns: long <BR>Method signature: 
long next(long A)<BR>(be sure your method is public) <BR>
<DIV class=newscontenttitle2>Constraints:</DIV>A 取值范围是[0， 10^17]，注意是闭区间。 
<DIV class=newscontenttitle2>Examples:</DIV>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>0)</B></TD>
    <TD>54</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns： 56</TD></TR>
  <TR>
    <TD></TD>
    <TD>大于54的最小数字是55，但55不是“不重复数”。下一个数字是56，它满足条件。</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>1)</B></TD>
    <TD>10</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns： 12</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>2)</B></TD>
    <TD>9</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns： 10</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>3)</B></TD>
    <TD>98</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns： 101</TD></TR>
  <TR>
    <TD></TD>
    <TD>99和100都不是“不重复数”， 101是。</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>4)</B></TD>
    <TD>21099</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns： 21201</TD></TR></TBODY></TABLE>
<DIV class=newscontenttitle3>解题报告:</DIV>The first solution that one could think 
of is to just increase A until it becomes a "unrepeating" number. Verifying that 
a number is unrepeating requires to decompose it into a list of digits, which is 
a simple task. Unfortunately, the constraints for the problem said that A can be 
as large as 10^17, we can notice that with a value of A equal to 1 and 17 zeros, 
our algorithm would take a lot of time before the two most significant repeated 
digits are dealt with.<BR><BR>However, the observation about spending too much 
time before dealing with significant repeated digits can be helpful. A good idea 
to optimize the previous algorithm would be to simply increase the digits that 
we need to increase. Instead of increasing the whole number until the repetition 
is handled correctly. This is actually an idea good enough to solve the problem. 
Unfortunately a lot of coders didn't consider special cases when implementing it 
which caused plenty of failed solutions. This was mostly due to the examples all 
having the repeated numbers in the least significant digits, which made it 
challenging to analyze the problem correctly. Let's analyze a good case in order 
to design an algorithm, A = 122055123, since the result must be greater than A, 
we will begin with 122055124:<BR><BR>We find a first pair of repeated digits 
"22", the number needs to be changed within the second '2', we might increase 
the left side of the number and leave the other side intact.<BR><BR><IMG 
height=114 alt="" src="2010网易编程挑战赛.files/news1pic1.png" width=327 border=0> 
<BR><BR>Is this a good result? It probably isn't. Although we have dealt with 
the pair of '2's , the right side of the number could actually be smaller (we 
need to find the smallest "unrepeating number" greater than A). Some quick 
analysis could show that the minimum 9 digits unrepeating number beginning with 
123 would be : "123010101", although we could base our solution on adding this 
repeating 01.. pattern to the right side of the number, it is not convenient as 
we will have to deal with special cases. (I.e: pairs of 99 may add new repeating 
pairs in more significant digit positions) Not handling these special cases 
correctly caused many solutions to fail. A more convenient solution would be to 
replace the right side of the number with zeros, and just repeat this process 
going from the most significant digit to the least significant digit until the 
number becomes unrepeating: <IMG height=410 alt="" 
src="2010网易编程挑战赛.files/news1pic2.png" width=327 border=0> <BR><BR>A big numbers 
class or string manipulation would be helpful in Implementing this algorithm but 
was not necessary, it was possible to implement it using arithmetic and powers 
of 10 to handle the digits:<BR><BR><PRE>long getNext( long A)
{
    A++;
    bool done = true;
    do {
        long d = 1;
        while (d*10 &lt; A) //find the higest power of 10
           d*=10;            // that is smaller than A
        
        done = true;
        while (d &gt; 1) {  //iterate valid powers of 10 from highest to lowest (10)
            long nd = d / 10;
            if ( (A / d) % 10 == (A / nd) % 10 ) { //compare the digits at these two consecutive positions
                A/= nd;    //increment the left  side
                A++;       
                A*= nd;   //replace the right side with zeros.
                done = false;
            }
            d = nd;
        }
    }
    while (! done);
    return x;
}


</PRE><!-- 第二条开始 -->
<DIV class=newscontenttitle>&nbsp;&nbsp;题目: UnrepeatingNunbers (350 
points)</DIV>
<DIV class=newscontenttitle2>Problem 
Statement:</DIV>“回文分数”游戏并不简单，游戏目标是修改最多maxChanges个字符使得一个字符串的回文分数最高。只允许修改，不许增加或者删除字符。一个字符串的回文分数定义如下：<BR><BR>- 
如果字符串不是回文串，则分数为0。<BR>- 如果字符串是回文串，且长度为奇数，则分数为1。<BR>- 
如果字符串是回文串，且长度为偶数，设它的一半子串的回文分数为K（两个一半子串得分一定相同），则分数为K + 
1。<BR><BR>给定一个字符串word和一个int型数maxChanges，返回最多修改maxChanges个字符后最大可能的回文分数。 
<DIV class=newscontenttitle2>Definition:</DIV>Class: 
MaximumPalindromeScore<BR>Method: maximize<BR>Parameters: String, 
int<BR>Returns: int<BR>Method signature: int maximize(String word, int 
maxChanges) <BR>(be sure your method is public)<BR>
<DIV class=newscontenttitle2>Notes</DIV>回文串的定义是一个字符串从前向后读和从后向前读完全一样。 
<DIV class=newscontenttitle2>Constraints </DIV>- word包含1到50个字符。 <BR>- word 
只包含小写字母 ('a'-'z')。<BR>- maxChanges 取值范围是[0，50]，闭区间。 
<DIV class=newscontenttitle2>Examples </DIV>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>0)</B></TD>
    <TD>"coder" 2</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns： 1</TD></TR>
  <TR>
    <TD></TD>
    <TD>把c改成r，把e改成o，得到“rodor”，这是一个奇数长度的回文串，所以得分为1。</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>1)</B></TD>
    <TD>"abcbxabcba" 1</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns：2</TD></TR>
  <TR>
    <TD></TD>
    <TD>把x改成a，得到“abcbaabcba”，偶数长度，它的一半子串是“abcba”，该子串是一个奇数长度的回文串，所以子串分数为1，因而最后得分是2。</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>2)</B></TD>
    <TD>"abcdefghijklmnop" 15</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns： 5</TD></TR>
  <TR>
    <TD></TD>
    <TD>可以把这个字符串修改成“aaaaaaaaaaaaaaaa”，“eeeeeeeeeeeeeeee”等串，回文得分为5。</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>3)</B></TD>
    <TD>"ssssssssssssssss" 15</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns：5</TD></TR>
  <TR>
    <TD></TD>
    <TD>无需做改变。</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>4)</B></TD>
    <TD>"vyyvvzzvvxxvvxxv" 4</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns：3</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>5)</B></TD>
    <TD>"a" 0</TD></TR>
  <TR>
    <TD></TD>
    <TD>returns：1</TD></TR></TBODY></TABLE>
<DIV class=newscontenttitle3>解题报告:</DIV>A first useful observation is to notice 
that the palindrome score of a word cannot become too high, in fact, the maximum 
score a word of length n could have is log2(n). This means that even for n=64, 
the maximum score possible is 6.<BR><BR>It would be possible to make a function 
isPossible(word,S,maxChanges) that verifies a palindrome score S is possible for 
a certain word after maxChanges character changes. This algorithm can help us 
solve the problem, we can iterate for all possible values of S from larger ones 
to 0. Once we find a value of S that is possible, return it since it is the 
maximum palindrome score for that case.<BR><BR>The problem is reduced to how to 
code the isPossible() function. A way to solve this subproblem is to first 
calculate the minimum number of characters in the word that have to be modified 
for the word to have a palindrome score of S. For a word to have a certain score 
S, it needs certain characters in specific indexes to be equal. Let's first 
verify the case for which S=1, in this case, we simply require the word to be a 
palindrome. This means that the characters in the first half of the word must be 
equal to the opposite characters in second half of the word. If one of these 
pairs of characters contains two different ones, then at least one of them must 
be modified. <BR><BR><IMG height=117 alt="" 
src="2010网易编程挑战赛.files/news1pic4.png" width=272 border=0><BR><BR>In the above 
example, to the 'a' characters do not need to be modified, but 'b' or 'd' have 
to be changed. Since 'c' does not have a pair we do not need to change it 
either. Larger values of S are similar, for S=2 we require both halves to be 
palindrome and the word itself to be a palindrome as well:<BR><BR><IMG 
height=296 alt="" src="2010网易编程挑战赛.files/news1pic5.png" width=437 
border=0><BR><BR>In this case, 'a','d','a' and 'h' and 'b','b','b' and 'c' are 
groups of indexes that must be equal. For the first group it is convenient to 
change 'd' and 'h' to 'a', for the second group change the 'c' to 'b'. The 
minimum number of changes necessary for the word to have a palindrome score of 2 
becomes 3.<BR><BR>This allows us to determine an algorithm:<BR><BR>Group the 
indexes of the word into groups of indexes that must be equal.<BR><BR>For each 
group, pick the most common character and count the number of indexes of the 
group with a different character. The sum of all these counts becomes the 
minimum number of changes that is necessary for the word to have a score 
S.<BR><BR>Grouping the indexes can be done easily by, for example, using a 
recursive algorithm. The rest of the solution can be coded once we have this 
grouping function.<BR><BR>int totalGroups = 0<BR>int group[]<BR><PRE>// Groups the first L indexes of a word in groups such that if the indexes
// of a word of length L of each group were equal, the palindrome score
// for the word would be S
GroupIndexes(L, S)
{
    // Calculate groups for the first half:
    if ( S == 0) {
        // If S is 0, then each character can be different:
        for (int i=0; i<L; (S while } S++; score. higher a ="2;" x="L;" allow to even be must length the { 0) x%2="=" while( int S length? this of word for score valid maximum is what L="word.length();" maxChanges) word, maximize(String j--; i++, group[j]="group[i];" i<="j)" ( j="L-1" i="0," half second first in groups mirror 1) - 2, GroupIndexes(L half: evaluate recursively else totalGroups="L;" group[i]="I" i++)> 0) {
        GroupIndexes( L, S);
        int required = 0;
        for (int i = 0; i&lt; totalGroups ; i++) {
            int x = MAX_INT; // number of changes required for this group
            
            // Try assigning each possible character to this group, pick
            // the one that requires least changes
            for ( ch = 'a'; ch&lt;='z'; ch ++) {
                int t = 0 ;
                for (int j=0; j&lt; L; j++)
                    if( group[j] == i) {  //only consider indexes in the current group
                        if ( word[j] != ch)
                            t ++;
                    }
                x = min( x, t )
            }
            required = required + x;
        }
        if ( required &lt;= maxChanges) //if the required of modifications does not exceed
            return S;                // maxChanges, then S is our result.
            
        S--;
    }
    return 0; // We could not find a better score than 0.
}
</PRE><!-- 第三条开始 -->
<DIV class=newscontenttitle>&nbsp;&nbsp;题目: RobotKing (1000 points)</DIV>
<DIV class=newscontenttitle2>Problem 
Statement:</DIV>“机器人国王”是一个比较复杂的游戏。一个矩形棋盘包含了NxM个单元。选手必须把棋盘上的国王移动到多个胜利单元中的任一个以获得胜利。但是同时还有多个机器人也能够移动国王，这使得选手的目标很难达到, 
选手唯一的优势是他有先手。<BR><BR>在选手每次移动时，他可以按照对角线，水平或者垂直方向把国王移动到一个相邻的空单元中。他也可以选择不移动国王。之后每个机器人会依次进行决策。每个机器人都有一个预定好的方向 
(上，下，左，右)，他们会按照各自预定的方向移动国王。只要该方向没有障碍物就会移动，如果碰到障碍物，机器人在该轮不会移动国王。<BR><BR>选手在国王移动到胜利单元时获得胜利，无论是选手自己还是机器人把国王移动到胜利单元选手都算胜利。有两种情况选手会失败：<BR><BR>- 
某个机器人把国王移动到棋盘外<BR>- 
选手和每个机器人每次决策(即便不移动)都算一轮，在maxTurns轮移动后，国王一直没有到达过胜利单元<BR><BR>选手在最开始是不知道机器人的预定方向的。他只知道每个机器人有且仅有两个可能的预定方向和各自的概率。这个信息会通过String[] 
robotMoves给出，其中每个元素表示一个机器人。每个元素都为“Direction1 Direction2 
P”这样的格式(引号只是用于解释)，其中P是一个整数，代表了Direction1的概率。每个Direction1，Direction2都是"D", "U", 
"L", 
"R"中的一个(引号只是用于解释)，这些字母依次表示上，下，左，右。这些方向是在游戏一开始就被确定下来，并且在整个游戏中都不会被改变。机器人在robotMoves中的顺序也就是他们做决策的顺序。<BR><BR>给定String[] 
board表示棋盘的信息。board中第i个元素的第j个字符表示棋盘的第i行，j列，其中第0行是最上面一行，第N-1行是最下面一行，第0列是最左边一列，第M-1列是最右边一列。'K'是国王的起始位置，'S'是胜利单元，'.'是空单元，'#'是障碍物。假设选手的决策总是以最大概率获得胜利，返回选手赢得游戏的概率。 

<DIV class=newscontenttitle2>Definition:</DIV>Class: RobotKing <BR>Method: 
calculateWinProbability<BR>Parameters: int, String[], String[] <BR>Returns: 
double<BR>Method signature: double calculateWinProbability(int maxTurns, 
String[] robotMoves, String[] board) <BR>(be sure your method is public) 
<DIV 
class=newscontenttitle2>Notes:</DIV>虽然选手在最开始是不知道每个机器人的预订方向的，但是在每个机器人的一轮决策后(如果有实际移动)选手就能够知道对应的方向并把这个信息用于之后自己的决策中。返回值必须保证绝对和相对误差不超过1e-9。 

<DIV class=newscontenttitle2>Constraints:</DIV>maxTurns 取值于1~100, 
含1和100。<BR>robotMoves 包含1~5个元素，含1和5。<BR>robotMoves中的每个元素都是如题目描述中所说的"Direction1 
Direction2 P"格式，并且最开始和最后都没有多余空格，相邻元素之间也只有一个空格进行分割。<BR>robotMoves 
的同一个元素中的Direction1和Direction2是肯定不同的。<BR>robotMoves中的每个P都在0~100之间，含0和100。<BR>robotMoves中的所有P都没有无意义的0前缀。<BR>board包含2~15个元素，含2和15。<BR>board的每个元素包含2~15个字符，含2和15。<BR>board的每个元素都包含相同个数的字符。<BR>board的每个元素都只包含'K', 
'.', 'S'和'#'.<BR>board包含有且仅有一个'K'. <BR>board包含至少一个'S'. <BR>
<DIV class=newscontenttitle2>Examples:</DIV>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>0)</B></TD>
    <TD>10 {"R L 25"}</TD></TR>
  <TR>
    <TD></TD>
    <TD>{"S.", "..", "..", "K."}</TD></TR>
  <TR>
    <TD></TD>
    <TD>Returns: 0.75</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>1)</B></TD>
    <TD>33 {"U D 50", "R L 100", "R L 100"}</TD></TR>
  <TR>
    <TD></TD>
    <TD>{"...", "K.S", "..."}</TD></TR>
  <TR>
    <TD></TD>
    <TD>Returns: 1.0</TD></TR>
  <TR>
    <TD></TD>
    <TD>这个例子中的最好战略是在第一步不移动国王</TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>2)</B></TD>
    <TD>5 {"R L 50", "R L 50"}</TD></TR>
  <TR>
    <TD></TD>
    <TD>{"S..###", "##..##", "###.K#"}</TD></TR>
  <TR>
    <TD></TD>
    <TD>Returns: 0.25</TD></TR>
  <TR>
    <TD></TD>
    <TD>只有一种可能把国王在5步或者以内移动到胜利单元，也就是两个机器人预订移动方向都是向左的情况 </TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=30><B>3)</B></TD>
    <TD>550 {"D U 100", "U R 47"}</TD></TR>
  <TR>
    <TD></TD>
    <TD>{".......S", "S...####", "...#K###"}</TD></TR>
  <TR>
    <TD></TD>
    <TD>Returns: 1.0</TD></TR>
  <TR>
    <TD></TD>
    <TD>第一个机器人的移动方向是100%向下的，而第二个机器人的移动方向是向上或者向右。在选手第一次移动时，他应该把国王沿对角线向左上单元移动。之后第一个机器人因为下面单元有障碍物而不会移动国王。而第二个机器人可能向上移动或者因为右侧有障碍物而不移动。两种情况下，选手都会知道这个机器人的预订移动方向。如果是向上，则选手可以通过到达左侧的胜利单元获得胜利；如果是向右，则选手可以通过到达右侧的胜利单元而获胜。</TD></TR></TBODY></TABLE>
<DIV class=newscontenttitle3>解题报告:</DIV>This problem required knowledge of 
dynamic programming / memoization and also probability theory. Even though the 
most experienced programmers noticed the dynamic programming solution soon 
enough, it was still a hard to implement solution that required time to be done 
correctly. There are also details to consider about the situations in which the 
player can learn what direction was assigned to the robot and when he is not 
able to do it. Let us start by solving this simpler yet important subproblem 
first.<BR><BR>If it is a robot's turn and the player does not yet know what 
direction was assigned to it, then there are two possible cells in the board to 
which the robot could move, each determined by the robot's predefined 
directions. These cells are different most of the times, so it should be simply 
for the player to know what direction the robot picked by seeing the new 
position of the king. There is one exception though, when there is an obstacle 
in the new cell, the robot is not going to make a move in its turn, this adds a 
possibility that both of the possible directions of a robot would end in the 
same cell (if both directions lead the king to an obstacle). Fortunately, the 
case in which both directions lead to an obstacle is the only one in which the 
player will not know the robot's direction after its turn.<BR><BR>Let us now 
verify a player's turn, the player must decide between up to 8 possible cells to 
move the king to. The player may also decide not to move the king, for 
simplicity, we will consider the decision not to move the king as a decision to 
"move" the king to the cell in which it already is. Let's say the player knows 
in advances what the probability to win for each of these moves is. The player's 
moves should be done in a way that increases his probability to win, and 
therefore he will always pick the cell that will give the maximum probability to 
win.<BR><BR>The problem becomes how to know the probability of these cells. In 
fact, the game itself does not depend only on the cell where the king is 
located. A more accurate state of the game considers also the number of turns 
that we have had so far, whether the current turn goes to the player or a robot 
(we can find this based on the number of turns) and the current location of the 
king. There is another piece of information left, for each robot in the game, 
the player may already know that the robot has picked its first direction or the 
second one, or the player may ignore what direction the robot chose. Since there 
are 3 states for each robot (unknown, direction 1 picked, direction 2 picked) 
and we will need at most 3number of robots states to describe what we know about 
the robots. This leads to O( w * h * maxTurns * 3r ) states, where w and h are 
the width and height of the board and r is the number of robots.<BR><BR>Let's 
define a function Probability(x,y, turn, robotvec ) that returns the probability 
to win for a given game state where (x,y) is the position of the king, turn is 
the number of turns played so far and robotvec is an array that contains for 
each robot, 0 if the robot's direction is unknown, 1 if it is known that the 
first direction was chosen and 2 otherwise. We can easily solve the most basic 
cases: if the king is currently at a winning cell, the probability is 1.0 (the 
player already won). If turn is equal to maxTurns or if the location of the king 
is outside the board, the probability to win is 0.0 (the player already 
lost).<BR><BR>There are other possible states, for which we must first decide 
whether the turn belongs to the player or to a robot. This information is 
implicit in turn. If there are r robots, the first turn (turn=0) belongs to the 
player and so do all turns for which turn is a multiple of (r+1). Otherwise, the 
turn belongs to a robot, we can identify the number of the robot by using a 
modulo operation: turn%(r+1) - 1.<BR><BR>In the case of a player turn, we should 
use the logic we described above, for each possible new location (nx,ny) the 
player may move the king to, calculate the probability to win the game if that 
movement is done (which we can recursively calculate by calling 
Probability(nx,ny, turn+1, robotvec ) ). Pick the cell that gives the best 
probability, and return this probability.<BR><BR>For the robots' turns, there 
are three possible cases:<BR><BR>The player may already know the direction that 
was picked for the robot, in which case we get the position (rx,rx) to which the 
robot will move the king and return Probability(rx,ry, turn+1, robotvec ). 
<BR><BR>Another case is when the player does not know yet what direction was 
assigned to the robot, but can find out what direction it was depending on the 
robot's move (i.e. when at least one of the directions can take the robot to an 
empty cell) in this case, we can get both possible locations (x1,y1) and (x2,y2) 
and using the rules of probabilities (knowing that P is the probability the 
robot will be assigned direction1) we may return P * Probability(x1,y1, turn+1, 
robotvec1 ) + (1 - P) * Probability(x2,y2, turn+1, robotvec2 ) where robotvec1 
is a new version of robotvec such that the robot's state is changed to 1 and 
robotvec2 is the version in which the robot's state changes to 2. When both of 
the robot's directions would lead it to leave the king in its current cell, the 
state only changes in the number of turns played so far, so we return 
Probability(x,y, turn+1, robotvec ) . <BR><BR>This recursive solution correctly 
solves the problem. However, it will time out in its current state. We should 
consider memoization to improve its execution time. Since w,h&lt;=15, 
maxturns&lt;=100 and &lt;=5, the maximum number of states is 5467500 which just 
fits in memory. Also, every state s result is dependent only on the solution for 
cases with a higher value used for turn, which means that there are no cyclecs 
in the recurrence so implementing memoization is possible. You can use a map / 
hashtable structure to associate probabilities to each of the game states. Most 
coders that solved the problem during the match used a double array of size 
[15][15][101][243] to store the information of each state, the trick was to 
store robotvec as a number from 0 to 242 and use base-3 logic to decode that 
number into the array and vice versa.<BR><BR></DIV><!-- 概述内容结束 --></DIV><!-- 左栏结束 --><!-- 右栏开始 -->
<DIV class=right><!-- 游戏入口开始 -->
<DIV class=gameenter><A href="http://www.youdao.com/nanti/mi2010/" 
target=_blank><IMG height=95 alt="" src="2010网易编程挑战赛.files/game_banner.jpg" 
width=240 border=0></A></DIV><!-- 游戏入口结束 -->
<DIV class=ver15right></DIV><!-- 竞赛通知开始 -->
<DIV class=notice_area_top></DIV>
<DIV class=notice_area_middle>
<DIV class=content><IMG alt="" src="2010网易编程挑战赛.files/shouye_list_point.gif" 
align=absMiddle border=0><A 
href="http://www.youdao.com/nanti/notice.html">“有道难题2010”练习赛5月24日举行</A><BR></DIV></DIV>
<DIV class=notice_area_bottom></DIV><!-- 竞赛通知结束 -->
<DIV class=ver15right></DIV><!-- poj平台开始 -->
<DIV class=poj_area_top></DIV>
<DIV class=poj_area_middle>
<DIV class=content>熟悉POJ平台，模拟比赛环境，快来POJ平台试试身手<BR><A 
href="http://acm.pku.edu.cn/JudgeOnline/" target=blank>现在就去» </A></DIV></DIV>
<DIV class=notice_area_bottom></DIV><!-- poj平台结束 -->
<DIV class=ver15right></DIV><!-- 温馨提示开始 -->
<DIV class=clew_area_top></DIV>
<DIV class=clew_area_middle>
<DIV class=content>欢迎订阅大赛信息以便及时得到最新赛报和相关信息。<BR>
<DIV 
style="PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; PADDING-TOP: 5px"><A 
href="http://reader.youdao.com/b.do?keyfrom=nanti&amp;url=http%3A%2F%2Fwww.youdao.com%2Fnanti" 
target=blank><IMG height=20 alt="" src="2010网易编程挑战赛.files/youdao_button.gif" 
width=105 border=0></A></DIV>
<DIV 
style="PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 15px; PADDING-TOP: 5px"><A 
href="http://www.youdao.com/nanti/rss.xml" target=blank><IMG height=20 alt="" 
src="2010网易编程挑战赛.files/rss_button.gif" width=105 border=0></A></DIV><IMG 
height=13 alt="" src="2010网易编程挑战赛.files/shouye_list_point.gif" width=13 
align=absMiddle border=0>在网易微博上关注“<B>有道搜索</B>”<BR><A 
href="http://t.163.com/Youdao" target=blank>http://t.163.com/Youdao</A><BR><IMG 
alt="" src="2010网易编程挑战赛.files/shouye_list_point.gif" align=absMiddle 
border=0>在新浪微博上关注“<B>有道搜索</B>”<BR><A href="http://t.sina.com.cn/youdao2010" 
target=blank>http://t.sina.com.cn/youdao2010</A> </DIV></DIV>
<DIV class=notice_area_bottom></DIV><!-- 温馨提示结束 -->
<DIV class=ver15right></DIV><!-- 互动讨论开始 -->
<DIV class=discuss_area_top></DIV>
<DIV class=discuss_area_middle>
<DIV class=content><IMG height=20 alt="" src="2010网易编程挑战赛.files/hudong_icon.gif" 
width=20 align=absMiddle border=0>&nbsp;<A 
href="http://tie.youdao.com/tl_-8833529291065876902?keyfrom=nanti" 
target=blank>去有道快帖和大家一起交流 »</A> </DIV></DIV>
<DIV class=notice_area_bottom></DIV><!-- 互动讨论结束 --></DIV><!-- 右栏结束 --></DIV><!-- 内容结束 --><!-- 容器结束 --></DIV>
<DIV class=ver20all></DIV><!-- 版权信息开始 -->
<DIV id=copyright_navigation>
<P class=gray>©2010 网易公司 京ICP证080268号 </P></DIV><!-- 版权信息结束 -->
<SCRIPT type=text/javascript>
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</SCRIPT>

<SCRIPT type=text/javascript>
try {
var pageTracker = _gat._getTracker("UA-6144188-5");
pageTracker._trackPageview();
} catch(err) {}</SCRIPT>
</BODY></HTML>
